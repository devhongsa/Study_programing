데이터베이스 설계이론 

스케일 업(scale up) : 서버의 기능을 높임
스케일 아웃(scale out) : 서버를 여러대로 늘림

데이터베이스는 웹서버에 비해 스케일업, 스케일 아웃하는 것이 비용이 상당하게 든다. 
그렇기 때문에 데이터베이스에서 병목현상이 자주 발생 할 수 밖에 없고, 이를 해결 하기위한 다양한 방법들이 존재한다. 
대표적인 방법은 캐시를 이용한 방법이다. 
또한 데이터베이스를 잘 설계하여 조회 쓰기 과정을 효율적으로 수행할 수 있게 하는 방법이다.


데이터베이스 정규화 : 중복을 최소화하게 데이터를 구조화하는 프로세스

정규화 특징
1. 중복을 제거하고 한 곳에서 관리 (원본데이터를 한곳에서만 관리하고, 다른 곳에서 이 데이터를 조회할때는 원본데이터를 참조해서 조회하도록함)
2. 데이터 정합성을 유지하기 쉬움.(즉 같은 데이터가 여러군데 나뉘어져 있으면, 그 데이터가 바뀌어야 할때 모든 곳에 가서 다 고쳐줘야하지만, 정규화하면 이런 불편이 감소한다)
3. 조회시 참조 발생 (즉 정규화를 한다는 것은 쓰기에 이점을 둔 방식)

반정규화 특징
1. 중복을 허용
2. 데이터 정합성을 유지하기 어려움 
3. 참조없이 조회 가능 

정규화시 고려해야 하는 것
- 얼마나 빠르게 데이터의 최신성을 보장해야 하는가?
- 히스토리성 데이터는 오히려 정규화를 하지 않는 것이 좋다.(바뀌지 않는 데이터)
- 데이터 변경 주기와 조회 주기는 어떻게 되는가?
- 객체(테이블) 탐색 깊이가 얼마나 깊은가?

정규화시에 테이블 조인
- 테이블 조인은 테이블의 결합도를 엄청 높이기 때문에, 조회 성능을 높이는 최적화 기법을 사용하는데 제한이 있을 수 있다.
- 조인으로 한번에 가져오는 것보다는 쿼리를 한번 더 쓰는것이 더 나을 수도 있음.

데이터베이스는 결국 디스크에 데이터가 저장된다. 디스크는 읽고 쓰는 시간이 메모리보다 훨씬 느리기 때문에
메모리를 활용한 읽기 쓰기 기술이 필요하다. 
하지만 메모리의 특성상 서버가 다운되면 메모리에 있던 데이터는 모두 날아가기 때문에, 이를 방지하기 위한 WAL(Write Ahead Log)기술이 있다.
WAL은 쿼리내용을 로그파일로 저장해놓고 만약 메모리에 있는 데이터가 날아갈 시 이 파일을 로드해서 다시 작업을 시작할 수 있다. 

디스크에 데이터를 저장하는 방식은 랜덤I/O와 순차I/O가 있는데 랜덤은 디스크의 랜덤 저장위치에 찾아가서 저장하는 방식이고 
순차는 저장위치의 순서대로 데이터를 저장하는 방식이다.

랜덤IO는 순차IO보다 속도가 느리기 때문에, 결국 데이터베이스 성능의 핵심은 디스크의 랜덤IO를 최소화하는 것이다. 


데이터베이스 성능의 핵심 ** 인덱스 **
인덱스란 정렬된 자료구조를 말함. 예를 들어 유저들의 정보가 저장된 테이블에서 나이가 가장 어린유저를 찾고싶다고 하면
인덱스를 설정 안해줬을 경우 모든 유저들의 나이를 다 봐야된다. 
하지만 나이컬럼을 인덱스로 설정해준다면 내부적으로 나이순으로 정렬된 테이블에서 첫번째 데이터를 찾기 때문에 조회하는데 훨씬 짧은 시간이 걸린다.
즉 인덱스의 핵심은 탐색(검색)범위를 최소화 하는 것이다.

클러스터 인덱스 
- 데이터 위치를 결정하는 키 값이다.
- MYSQL의 pk는 클러스터 인덱스다.
- MYSQL에서 pk를 제외한 모든 인덱스는 pk를 가지고 있다.

pk로 auto increment vs UUID ?


인덱스를 태웠을때 성능차이에 가장 중요한거는 인덱스를 태운 컬럼값이 분별력이 얼마나 있느냐이다.
예를들어 300만건의 데이터중에 인덱스를 태운 uid컬럼값이 100만건은 1, 200만건은 2 로 되어있다면  where uid = 2를 해도 200만건을 다 찾아봐야한다는 뜻이다.
근데 만약 300만건중에 date컬럼값이 300만건이 모두 다르다면 where date between 2022-01-01 and 2022-01-31을 했을때 걸러낼 수 있는 데이터가 엄청 많기 때문에 굉장히 빠른 속도로 찾아볼 수 있는 것임.

또한 복합인덱스를 태우면 where id = 2 and date between 2022-01-01 and 2022-01-31 와 같은 복합where 쿼리를 했을때 굉장히 빠른 속도로 찾을 수 있게 된다.
복합인덱스는 선두 인덱스가 중요한데 만약 선두 인덱스가 과일종류, 뒤에 인덱스가 원산지 종류라고 가정했을때 인덱스 테이블은 과일종류를 먼저 정렬하고, 과일종류가 같다면 
원산지 종류를 정렬해서 만들어지게 된다. 그러면 테이블상에서 보면 우선 원산지 종류는 정렬되어 있지 않기 때문에 where 원산지='usa'를 하더라도 성능의 차이를 볼 수가 없게된다.


인덱스 주의사항 
where age*10 = 20 과 같은 컬럼값을 변형시키는 쿼리문은 인덱스를 태울 수 가 없음.
where age = '1' 과 같이 age컬럼은 데이터타입이 int인데 string값을 넣으면 인덱스를 태울 수가 없음.
하나의 쿼리에는 하나의 인덱스 테이블만 탄다.(database 옵티마이저가 어떤 인덱스 테이블을 탈지 결정함)


커버링 인덱스
ex) age를 인덱스로 설정하면 인덱스 테이블에는 age 컬럼과 pk 컬럼이 존재하게되고, 만약 쿼리로 age와 pk만 찾는다면 인덱스 테이블에서 원본테이블을 안가더라도 쿼리를 끝낼 수 있다. 근데 만약 추가로 name도 얻고 싶으면 무조건 원본테이블을 가야하는데, 이때 limit, order by, offset, group by 같은 명령어로 인한 불필요한 데이터블록 접근을
커버링 인덱스를 통해 최소화 할 수 있다.

with 커버링 as(
    SELECT id 
    FROM 회원
    WHERE age < 30
    LIMIT 2
)
//여기서 인덱스 테이블이 limit 명령어까지 수행하게 하고 탐색범위를 줄여놓은상태

//이후 원본테이블은 인덱스테이블에서 줄여놓은 데이터를 가지고 조인해서 가져오기 때문에 불필요한 블록접근을 피할 수 있음.
SELECT name 
FROM 회원 INNER JOIN 커버링 ON 회원.id = 커버링.id




트랜잭션 ACID (데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 의미한다)
Atomicity(원자성) : All or Nothing 연산을 수행하다가 중간에 중단되지 않는다. MVCC는 이를 보장하기 위한 기술이다 
    MVCC : 예를 들어 홍사라는 유저와 유저의 잔액이 저장된 테이블이 있고, 홍사에게 1000원을 보낸다고 했을때,
           MVCC는 1000원을 보내기 전 잔액을 undo log에 저장해놓고, 만약 트랜잭션에 실패할 경우 이 undo log로 데이터베이스를 롤백하는 기능이다.

Consistency(일관성) : 트랜잭션이 종료되었을 때 데이터의 무결성이 보장된다.

Isolation(독립성) : 트랜잭션은 서로 간섭하지 않고 독립적으로 동작한다. 이 독립성을 위해서는 동시성을 포기해야되기 때문에 개발자가 격리레벨을 적당히 조절해줘야한다.

Durability(지속성) : 완료된 트랜잭션은 유실되지 않는다. WAL통해서


Isolation 문제 
Dirty Read : 아직 Commit 되지 않은 데이터를 읽어버리는 현상.
    예를들어 TX1 에서 홍길동이 김국밥에게 900원을 보내는 로직있다고 했을때 김국밥의 잔고에 900원이 추가가 되고나서 트랜잭션이 실패가 난다고 하면
    transaction에 의해 롤백이된다. 근데 롤백이 되기전에 이미 바뀌어진 김국밥의 잔고를 다른 TX2가 읽어 갔을때, 즉 TX1에서 아직 commit 되지 않은 데이터를 읽었을때 정합성을 잃게 된다. 이를 Dirty Read라고 한다.

Non Repeatable Read : 
    예를 들어 TX1 에서 홍길동의 잔고를 읽는 쿼리가 여러번 있다고 가정했을때 다른 TX2에서 홍길동의 잔고를 업데이트했을때, TX1에서는 홍길동의 잔고가 일정치 못하게 되는 현상이 있을 수 있게된다. 

Phantom Read : 
    예를 들어 TX1에서 잔고가 1000원 이상인 사람을 불러오는 쿼리를 여러번한다고 가정했을때, 만약 누군가 다른 사람의 잔고를 업데이트하면, TX1에서는 똑같은 쿼리지만 
    갑자기 없던 데이터 결과가 생기거나 있던 데이터가 없어지는 결과가 나올 수 있다.

격리레벨 
Read Uncommitted : 아직 commit되지 않은 데이터도 읽을 것이다. (위에 3문제 모두 발생)
Read Committed : commit된 데이터만 읽을 것이다. (Dirty Read 발생하지 않음. 나머지 2문제 발생)
Repeatable Read : commit된 데이터만 읽고, 나보다 나중에 시작된 TX의 커밋된 데이터는 읽지 않음.(Non Repeatable Read 발생하지 않음)
Serializable Read : 모든 Isolation 문제 발생하지 않음.

주로 실무에서는 Read Committed, Repeatable Read 격리레벨을 사용함 Read Committed를 제일 많이 사용. Serializable Read는 동시 처리량을 너무 낮추기때문에 성능 저하가 심하고 Read Uncommitted는 이상현상이 너무 많이 발생하기 때문.