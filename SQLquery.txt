https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all  //sql문 테스트
https://www.hackerrank.com/domains/sql
https://leetcode.com/problemset/database/



mac 경로
/Library/PostgreSQL/14/data/pg_hba.conf
/opt/homebrew/var/postgres/pg_hba.conf
/opt/homebrew/var/postgres/postmaster.pid

windows
// postgresql 터미널 로그인
// psql -U [유저이름] -d [db이름]
// postgres=#  : #은 superuser  , postgres=>  : >는 superuser 아니라는 뜻 


\l : db목록보기  \du : 유저목록보기  \dt : 테이블목록보기  \dn : 스키마목록보기 
\connect [dbname] : db 접속 

CREATE USER [유저이름] WITH PASSWORD 'password';   // 새 유저 만들기 
GRANT ALL PRIVILEGES ON DATABASE [db이름] TO [username]     // 특정유저에게 디비에 대한 모든 권한 주기. 
GRANT SELECT ON [테이블이름] TO [유저이름]   //특정유저에게 테이블 접근권한 주기  SELECT 대신 ALL PRIVILEGES 쓰면 모든권한 
ALTER USER [유저이름] WITH CREATEDB   //db생성권한 주기 


// postgresql 환경변수 Path 설정.   bin 폴더로 경로설정해주기 
// 터미널에서 psql -U [username] -d [dbname] -h [host] --password
//  /d  하면 table 목록 뜸 

CREATE SCHEMA [스키마이름];

# CREATE TABLE 
CREATE TABLE Temp_Table (
field1    char(10)    NOT NULL ,
field2    char(10)    DEFAULT 'Y' ,
field3    DECIMAL(8,2)  ,
field4    varchar(1000) 
);

#TABLE 변경하기
ALTER TABLE Temp_Table ADD field5 char(10);
ALTER TABLE Temp_Table DROP COLUMN field5 ;

ALTER TABLE foo ADD UNIQUE (thecolumn);   //unique key 설정하기

UPDATE table SET column = '홍길동' WHERE U_ID = 'roqkfwk';


#INSERT 
INSERT INTO Temp_Table
VALUES('data2','data2-2','data2-3','data2-4','data2-5','data2-6','data2-7','data2-8','data2-9','data2-10');

INSERT INTO Temp_Table(field1, field2, field5, field6, field7, field8, field9, field10)
VALUES('data5','data5-2','data5-5','data5-6','data5-7','data5-8','data5-9','data5-10');

insert into public."User" ("walletAddress", "contractAddres") values ('address','address2')   값이 숫자면 숫자만 입력 


#DELETE
delete from balance.userbalance where btc>0;
delete from balance.userbalance

#UPDATE 
UPDATE users SET name = 'coco' WHERE name = 'bobo';


# 테이블 복사하기 
CREATE TABLE newtable AS SELECT * FROM oldtable;
CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR NOT NULL);      //serial를 붙이면 매번 user데이터를 넣을때마다 고유한 id값을 안넣어줘도 됨.


#where문 
select \"walletAddress\", \"timestamp\", \"to\", \"amount\",\"contractAddress\" from txhistory.txshistory1 where \"timestamp\" between {timestamp1} and {timestamp2} and (\"contractAddress\"='{eth}' or \"contractAddress\"='{usdt}' or \"contractAddress\"='{usdc}' limit 50);


WHERE IN 
SELECT user_num  ,  user_id , user_mobile , user_gender , user_amount  , user_addr  
FROM  User_Table
WHERE user_id  IN ('user1','user3')   /// WHERE NOT user_id  IN ('user1','user3')
ORDER BY user_num DESC; 
## IN ()  괄호안에 있는 값들 중 하나라도 만족하면 조건충족. or의 업그레이드 버전임. IN 연산이 OR 연산보다 빠르다 
## WHERE NOT 이면 user1, user2가 아닌값이면 조건충족함.


###### 테이블 복사하기 #######
CREATE TABLE "public"."newAddressSchedule2" AS SELECT * FROM "public"."newAddressSchedule"












https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all  //sql문 테스트
https://www.hackerrank.com/domains/sql
https://leetcode.com/problemset/database/
###################  inflearn sql ###########################
SELECT DISTINCT *                                   // DISTINCT는 값이 중복되지 않게 나오게함
FROM Customers
WHERE CustomerID < 50           
WHERE CustomerName < "B" AND Country = 'Germany'     //  문자열도 비교가능 B 이전 문자 A로 시작하는 name만 불러오기
WHERE country (NOT) LIKE '%r%'                       // %는 어떤 문자열이 와도 상관없다는뜻, r이 들어가는 country 이름 찾기  NOT을 넣으면 r이 들어가지 않는 데이터 찾기
WHERE country LIKE 'B_____'                         // _ 이것은 문자 길이를 뜻함. B로 시작하는 고정된 문자열 길이를 찾겠다는뜻
WHERE discount LIKE '50\%'                          // %자체의 문자열을 찾고싶으면 역슬래시 넣으면됨.
//찾고자하는 데이터값이 명확하다면 =을 쓰는것이 LIKE보다 훨씬 빠르다
WHERE country IN ('Germany', 'France')              // country가 germany나 france 인 사람, OR을 써도 되는데 그러면 구문이 너무 길어짐
WHERE coustomerID BETWEEN 3 AND 5                   // id가 3과 5사이인 사람, 3과 5 포함
WHERE customerID IS NULL                            // null 값 찾기  NAN은 숫자가 아닌거 
ORDER BY customerid DESC                            // 내림차순 정렬 , ASC 는 오름차순 정렬 default는 ASC 안써주면 ASC로 자동정렬 
LIMIT 10

비교연산자 : <, >, <=, >=, = , <>(!=)
논리연산자 : AND, OR 


//////문자열 자르기 

SELECT LEFT('20140323', 4)   //2014
SELECT RIGHT('20140323', 4)  //0323 
SUBSTR("20140323",1,4)          // 1번째부터 4번째까지 , 2014 
SUBSTR("20140323",5)            // 5번째부터 끝까지 0323 

SELECT name FROM students WHERE marks > 75 ORDER BY Right(name,3), id    // id는 세컨더리 정렬기준
SELECT name, Right(name,3) from students

////// 소수점 자리 
CEIL() 올림 
FLOOR() 내림 
ROUNT(long, 4)  // 4자리수 반올림
산술연산 + - * /


////// 집계함수 
COUNT(*)   // row 개수를 세줌
COUNT(name)  // row는 7개라도 name값에 null값이 있으면 null값을 빼고 계산
COUNT(DISTINCT name)  // 중복값도 빼고 계산 
SUM(visits)
AVG(visits)   // 이경우에는 null 값이 포함되어있으면 없는걸로 취급함. null값을 0으로 생각하고 계산하고싶으면 SUM(visits)/COUNT(*)  이렇게 해줘야함.
MIN()
MAX()


///// GROUP BY 
SELECT supplierID, AVG(price) AS avg_price              // AS는 별명으로 부르겠다는 뜻 
FROM products
GROUP BY suppierID                  // suppierID 별로 price 평균낸값 추출
HAVING AVG(price) >= 100            // WHERE문은 GROUP BY 이전에 실행되기 때문에 WHERE AVG(price)>= 100 을 하면 안된다. 그래서 HAVING을 씀
ORDER BY AVG(price)

SELECT salary*months AS earnings, COUNT(*) FROM Employee GROUP BY earnings ORDER BY earnings DESC LIMIT 1;
// from -> where -> group by -> order by -> limit -> select 



///// CASE : 조건문
CASE 안에 조건문들을 나열해주고 마지막에 END로 마무리 
AS 'categoryName'은 CASE문으로 나온 결과RAW들의 컬럼이름 
SELECT CASE 
            WHEN categoryid = 1 AND supplierid = 1 THEN '음료'
            WHEN categoryid = 2 THEN '조미료'
            ELSE '기타'
        END AS 'categoryName', * , AVG(price)
FROM Products
GROUP BY categoryName


SELECT CASE
            WHEN A=B and B=C THEN 'Equilateral'
            WHEN A+B<=C or A+C<=B or B+C<=A THEN 'Not A Triangle'
            WHEN A=B or B=C or A=C THEN 'Isosceles'
            ELSE 'Scalene'
        END
FROM triangles
// CASE WHEN 절의 순서가 중요함. 첫번째 WHEN절에서 데이터가 'Equilateral'로 할당되었으면, 할당된 데이터는 그다음 WHEN절에서 고려대상이 되지 않음.


////피봇팅: 결과값이 행(raw)으로 늘어나는것이 아닌 열(column)로 늘어나게 하는것
SELECT AVG(CASE WHEN categoryid = 1 THEN price ELSE NULL END) AS category1_price,
       AVG(CASE WHEN categoryid = 2 THEN price ELSE NULL END) AS category2_price,
       AVG(CASE WHEN categoryid = 3 THEN price ELSE NULL END) AS category3_price
FROM products
//result 
categoryid1_avgprice     categoryid2_avgprice     categoryid3_avgprice      ...
20                          23                          33




/////// JOIN 
SELECT *
FROM orders
     INNER JOIN customers ON orders.customerID = customers.customerID
     INNER JOIN shippers ON orders.shipperID = shippers.shipperID
// orders 테이블과 customers 테이블엔 모두 customerID가 있고 이 두 테이블에서 customerID가 같은 데이터들만(교집합) 가져옴
// INNER JOIN은 테이블 A와 B의 교집합부분만 결과값으로 나옴

SELECT *
FROM customers 
    LEFT JOIN orders ON customers.customerID = orders.customerID
WHERE orderID IS NULL 
//orders 테이블에 없는 즉 주문을 한번도 안한사람이라도 customers테이블에 있으면 일단 가져와서 null값으로 처리함. 
//그래서 null값을 응용해서 주문을 한번도 안한사람을 where문으로 찾아낼 수 있음.
// LEFT JOIN은 customers테이블 내용은 다 나타내고, orders테이블과 교집합부분은 JOIN해서 나타내고, 교집합이 없으면 null값 
// FROM 테이블이 LEFT 테이블임.
// RIGHT JOIN은 반대 orders테이블 내용을 다 나타냄.
// FULL OUTRE JOIN은 2개 테이블 내용을 모두 나타냄
// LEFT, RIGHT는 모두 OUTER JOIN임 OUTER 생략가능 

SELECT country.continent, FLOOR(AVG(city.population))
FROM city
    INNER JOIN country ON country.code = city.countrycode
GROUP BY country.continent


///////// SELF JOIN : A테이블과 A테이블을 조인, 즉 A테이블의 컬럼들이 모두 독립적인 컬럼값들이 아닌 중복되는 컬럼값들이 존재 
            모든 Employee 정보가 있는 테이블에서 각employee마다 id가 있고, 어떤 employee의 상사가 누군지에 대한 managerid컬럼이 있을때
SELECT Employee.Name AS employee_name
     , Employee.Salary As employee_salary
     , Manager.Name AS manager_name
     , Manager.Salary AS manager_salary
FROM Employee 
     INNER JOIN Employee as Manager ON Employee.managerId = Manager.Id 
     WHERE Employee.Salary > Manager>Salary


///////// UNION: 테이블 구조는 같지만, recent테이블, past테이블로 나뉘어져있을때 두 테이블을 UNION 해주면 밑으로 이어붙여줌.(중복값 자동 제거)
SELECT * 
FROM Users_recent

UNION 

SELECT * 
FROM Users_past

UNION ALL을 하면 중복값상관없이 모두 합침

mysql은 지원하지않지만, INTERSECT(두 테이블의 교집합만 보여줌), EXCEPT(A-B를 보여줌, 차집합)