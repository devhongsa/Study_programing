Redis(Remote Dictionary Server)
redis 특징
Redis는 in-memory db 이기 때문에, 디스크에 저장하지 않고 메모리에 저장함.
메모리는 읽고 쓰는 속도가 디스크보다 약 40배가량 빠르지만 휘발성이라는 단점이 있음. 

redis의 가장 중요한 기능은 cache이다 이는 대규모 I/O처리에 적합한데
웹서버가 만약 수천만명의 요청에 의해 매번 데이터베이스에서 데이터를 꺼내온다면 퍼포먼스가 현저하게 떨어질것이다.
근데 그 데이터가 만약 자주 변경이 일어나지 않는 데이터라면 cache에 저장해놓고 바로바로 꺼내다가 쓰면 디비의 부하도 낮추고
요청응답시간도 현저하게 줄어들 것이다. 또한 좋아요나 채팅같은 대규모 요청이 있는 앱같은경우에도 cache에 데이터를 쌓아놓다가 
일정주기마다 데이터베이스에 업데이트해주면, 디비의 부하를 낮출 수 있게된다. 

디스크에 저장하는 데이터는 영속성을 유지해야하는 데이터를 위주로 저장하고(회원정보와 같은)
Redis는 로그인세션과 같이, 데이터가 날아가도 유저에게 치명적이지 않은 데이터를 위주로 저장하게 된다.

key-value store 방식 
    hash를 이용해 값을 바로 읽으므로 속도가 빠름 
    수평적 확장성이 뛰어남.(관계형 DB같은 경우 서로 연관이 있는 table들이 많아서 DB를 여러 서버에 나눈다고 했을 때, 이런 연관성때문에 수평적 확장이 어려움.)
    단점 key를 통해서만 값을 읽을 수가 있음
    범위 검색과 같은 복잡한 쿼리가 불가능 


redis 설치 
linux 
sudo apt-get update 
sudo apt-get upgrade 
sudo apt-get install redis-server
redis-server --version

macos 
brew install redis

docker로 설치
docker pull redis
docker run --name my-redis -p 6379:6379 redis
docker stop my-redis
docker start my-redis 
docker exec -it my-redis /bin/sh  : redis서버 커멘트쉘 실행 

redis-server : redis 서버 실행
redis-cli : redis 클라이언트 커맨트창 실행 
exit : 빠져나오기 

brew services start redis : 터미널 창을 닫아도 서버 계속 실행 
brew services stop redis 


################ redis 기본 명령어 모음 #################
keys * : 모든 키 보기, 성능에 영향을 주는 명령어라서 개발단계에서만 씀.
dbsize : key 몇개 있는지 
flushall : 모든 key-value 지우기 

** Strings
set key1 banana  : key-value 쓰기 
get key1 : key-value 읽기
del key1 : 데이터 지우기 
incr mycount : value값이 int로 취급하여 1 증가시키기 (데이터 원자성 보장: 여러서버가 동시에 수행해도 원자성 보장, value가 int가 아니면 오류)
decr mycount : 1감소시키기 
mset key1 milk key2 coffe : 여러 키에 대한 값을 한번에 저장
mget key1 key2 : 여러 키 값 한번에 get 

** Lists (linked list로 구현되어 있음)
lpush mylist apple : list 왼쪽에 요소 삽입
rpush mylist banana 
llen mylist : list의 길이
lrange 0 -1 : 0인덱스에서 -1(맨끝)까지의 데이터를 리턴
lpop mylist : list 맨 왼쪽요소 추출 (맨왼쪽요소를 리스트에서 삭제하고 나서 가져옴)
rpop mylist 

** Sets (중복된 데이터가 들어가지 않음. 검색이 빠름. 인덱스로 데이터 접근 불가)
sadd myset apple : set에 데이터 추가 (set은 위치인덱스로 데이터를 찾을 수 없음)
srem myset apple : 데이터 삭제 
scard myset : set의 저장된 아이템 개수 반환 
smembers myset : 저장된 아이템들 반환 
sismember myset apple : 특정값이 set에 포함되어 있는지 확인 (있으면 1 없으면 0)

** Sorted Sets
zadd myrank 1 apple 20 banana 30 grape : sorted set은 score값을 함께 넣어줘야함. score는 set에 순서를 부여해줌.
zrange myrank 0 1 withscores : score가 큰순서대로 0부터 1까지  
zrank myrank banana : 특정 값이 어떤 순위를 가지고 있는지 
zrevrank myrank banana : 내림차순 정렬일때 순위
zpopmin
zpipmax
zrem myrank apple

** hash 
hset user1 name bear age 10  : key는 user1이 되고 value에 field-value 쌍이 저장됨. (name: bear, age: 10)
hget user1 name : "bear"
hmget user1 name age : 1) "bear" 2) "10"
hincrby user1 count 2 : count필드의 값을 2 증가시킴 
hkeys user1 : 모든 필드 보여줌 
hdel user1 name

** Streams
xadd 
xlen
xrange
xread
xdel


#####################################################


################ redis conf 설정 #####################3
# vi 편집기로 설정 파일 조회(redis.conf)
sudo vi /etc/redis/redis.conf

# 최대 메모리 사양
# ->    최대 사용 메모리 사양을 256mb로 설정한다. 단위는 mb나 g 등 필요에 맞춰 적어주면된다.
maxmemory 256mb            

# 메모리 초과 사용 시 후처리 방식 설정
# ->    지금 설정한 allkeys-lru 옵션은 가장 오래된 데이터를 삭제하고, 새로운 데이터를 저장하는 옵션이다.
maxmemory-policy allkeys-lru

# 프로세스 포트
# ->    port 부분은 초기에 주석처리가 되어 있는데, 디폴트 값으로 6379 포트에서 동작한다. 
# ->    만약, 6379가 아닌 다른 포트를 설정하고 싶다면 주석을 해제하고 포트번호를 입력하면된다.
port 1234

# 외부접속 허용
# ->    기본 실행 환경은 localhost(127.0.0.1)로 되어있다.
# ->    만약, 모든 외부접속에 대한 허용을 하고 싶다면, 0.0.0.0 으로 변경하면 된다.
bind 0.0.0.0

# 비밀번호 설정
# ->    서버 접속에 비밀번호를 적용시키고 싶다면 아래와 같이 수정하자.
requirepass [접속 패스워드 입력]

# 암호화된 비밀번호가 필요하다면, 터미널에 다음 명령어로 생성 가능하다.
echo "MyPassword" | sha256sum
####################################################################





####################################################################
redis server 만들기
####################################################################

프로젝트폴더 생성
npx express-generator
npm install 
DEBUG=redis-server:* npm start
npm install redis
npm install axios

redis-server : redis 서버 가동 

////app.js
const express = require("express");
const redis = require("redis");
const redisClient = redis.createClient();
const axios = require("axios").default;

const app = express();

(async () => {
  redisClient.on("error", (err) => console.log("Redis Client Error", err));
  await redisClient.connect();
})();


const redisSet = async (key, value) => {
  await redisClient.set(key, JSON.stringify(value));
};

//middleware
const redisGet = async (req, res, next) => {
  const { id } = req.params;
  const data = await redisClient.get(id);
  console.log(data);
  data !== null ? res.send(JSON.parse(data)) : next();
};

app.get("/redis/:id", redisGet, async (req, res) => {
  const { id } = req.params;
  const { data } = await axios.request({
    method: "get",
    url: `https://reqres.in/api/product/${id}`,
  });
  redisSet(id, data);
  res.send(data);
});





####################################################################
redis 복구  : 패캠 대용량 트래픽 Part3 - Ch.10 
####################################################################
docker run -v $(pwd)/redis.conf:/redis.conf --name my-redis redis redis-server /redis.conf
1. RDB 
redis.conf 에서 복구 정책 관련 옵션 수정 가능 
save 60 10 : 60초마다 10개의 변경점이 있으면 dump.db 스냅샷 파일 생성
bgsave : 수동으로 스냅샷파일 만들기 


2. AOF
redis서버에서 실행되었던 모든 명령어들을 저장해두었다가, 재시작시 그 명령어들을 다시 재실행 
단점 : RDB 방식보다 파일 사이즈가 커짐 , 백업 복구 속도가 느림 
redis.conf 
appendonly yes : aof 방식 사용 
appendfilename appendonly.aof : 복구 파일이름 설정 
appendfsync (always, everysec, no) : fsync의 3가지 정책중 하나 선택, fsycn()호출은 OS에게 데이터를 디스크에 쓰도록함.
always : 커맨드가 실행될때마다 저장 , 성능저하가 심해서 잘 사용안함.
everysec : 1초마다 수행 , RDB성능과 비슷하여 이 옵션을 많이 사용함.
no : OS에 맡김 


3. Replica 복제 
백업만으로는 장애 대비에 부족 (백업실패, 복구시간)
아예 다른 노드로 미리 복제해 놓는 것 
master가 죽었을 경우 replica 중 하나를 master로 전환해 즉시 서비스 정상화 가능 

redis.conf 
replicaof 127.0.0.1 6379 : master서버의 6379포트에서 동작하고 있는 redis서버를 계속 복제해옴. master 노드는 rdb나 aof를 설정하고 있어야함.
만약 마스터노드가 백업설정을 안해놓은 상태에서 꺼지게 되면 비어있는 redis를 replica 노드가 복제해 오기 때문임.
replica-read-only 

docker-compose.yml 파일로도 master, secondery 노드 실행가능 

4. Sentinel 사용 